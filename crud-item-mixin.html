<link rel="import" href="dialog/vaadin-confirm-dialog.html">

<script>
  /**
   * Mixin for entity editor.
   */
  window.CrudItemMixin = subclass => class extends subclass {
    static get properties() {
      return {
        item: Object,
        dirty: Boolean,
        new: Boolean,

        _dialog: Element,
        deleteCaption: {
          value: 'Confirm Delete Item'
        },
        deleteMessage: {
          value: 'Are you sure you want to delete the selected Item?. This action cannot be undone.'
        },
        deleteOkText: {
          value: 'Delete'
        },
        deleteCancelText: {
          value: 'Cancel'
        },
        unsavedCaption: {
          value: 'Unsaved Changes'
        },
        unsavedMessage: {
          value: 'There are unsave modifications to the Item. Are you sure to cancel the edition.'
        },
        unsavedOkText: {
          value: 'Yes'
        },
        unsavedCancelText: {
          value: 'Back'
        }
      };
    }

    static get observers() {
      return [
        '_onItemChanged(item)',
        '_checkDirty(item.*)'
      ];
    }

    ready() {
      super.ready();
      Polymer.RenderStatus.afterNextRender(this, () => {
        this._dialog = document.createElement('vaadin-confirm-dialog');
        document.body.appendChild(this._dialog);

        this.parentElement.addEventListener('before-close', e => {
          this.dirty && e.preventDefault();
        });
      });
    }

    _onItemChanged() {
      if (!this._itemLock) {
        this.dirty = false;
        this.new = this.item && Object.keys(this.item).length === 0;
        this._originalItemString = JSON.stringify(this.item);

        // We reuse item name wich is more meaningful in declarative
        this._itemLock = true;
        this.item = Object.assign({}, this.item);
        this._itemLock = undefined;
      }
    }

    _checkDirty() {
      this.dirty = JSON.stringify(this.item) != this._originalItemString;
    }

    cancel() {
      if (this.dirty) {
        this._confirm(() => this.close(true),
          this.unsavedCaption, this.unsavedMessage, this.unsavedOkText, this.unsavedCancelText);
      } else {
        this.close();
      }
    }

    close(force) {
      // if forced set dirty to true to avoid preventing close on before-close phase
      this.dirty = !force && this.dirty;
      this.dispatchEvent(new CustomEvent('close', {bubbles: true, composed: true}));
    }

    save() {
      this.item = Object.assign(this.item, this.editable);
      this.dispatchEvent(new CustomEvent('save', {bubbles: true, composed: true, detail: this.item}));
      this.close(true);
    }

    delete() {
      this._confirm(() => {
        this.dispatchEvent(new CustomEvent('delete', {bubbles: true, composed: true, detail: this.item}));
        this.close(true);
      }, this.deleteCaption, this.deleteMessage, this.deleteOkText, this.deleteCancelText);
    }

    _confirm(callback, caption, message, okText, cancelText) {
      this._dialog.callback = callback;
      this._dialog.caption = caption;
      this._dialog.message = message;
      this._dialog.okText = okText;
      this._dialog.cancelText = cancelText;
      this._dialog.opened = true;
    }
  };
</script>
